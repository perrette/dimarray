<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modules and classes &mdash; dimarray 0.1.7.dev documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.7.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="dimarray 0.1.7.dev documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">dimarray 0.1.7.dev documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="modules-and-classes">
<h1>Modules and classes<a class="headerlink" href="#modules-and-classes" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-dimarray"></span><p>Dimarray module</p>
<dl class="function">
<dt id="dimarray.read_nc">
<tt class="descclassname">dimarray.</tt><tt class="descname">read_nc</tt><big>(</big><em>f</em>, <em>nms=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.read_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one or several variables from one or several netCDF file</p>
<p>f : file name or buffer or regular expression
nms, optional : variable name(s) to read_nc: list or str</p>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>indexing parameters similar to <cite>take</cite> are accepted:
indices : dict, provide indices or slice to extract {nm1:val1}
indexing : str, &#8216;values&#8217; (default) or &#8216;position&#8217; (integer position) similarly to <cite>take</cite>
tol : None or float, floating point tolerance when indexing float-arrays</p>
<blockquote>
<div>(default to None for exact match)</div></blockquote>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>additional keyword arguments depend on whether one or several files, one or several variables are required for reading (see below)</p>
</dd></dl>

<dl class="function">
<dt id="dimarray.stack">
<tt class="descclassname">dimarray.</tt><tt class="descname">stack</tt><big>(</big><em>arrays</em>, <em>axis=None</em>, <em>keys=None</em>, <em>align=False</em><big>)</big><a class="headerlink" href="#dimarray.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>stack arrays along a new dimension (raise error if already existing)</p>
<p>arrays: sequence or dict of arrays
axis, optional: str, new dimension along which to stack the array
keys, optional: stack axis values, useful if array is a sequence, or a non-ordered dictionary
align, optional: if True, align axes prior to stacking (Default to False)</p>
</dd></dl>

<dl class="function">
<dt id="dimarray.concatenate">
<tt class="descclassname">dimarray.</tt><tt class="descname">concatenate</tt><big>(</big><em>arrays</em>, <em>axis=0</em>, <em>check_other_axes=True</em><big>)</big><a class="headerlink" href="#dimarray.concatenate" title="Permalink to this definition">¶</a></dt>
<dd><p>concatenate several DimArrays</p>
</dd></dl>

<dl class="function">
<dt id="dimarray.broadcast_arrays">
<tt class="descclassname">dimarray.</tt><tt class="descname">broadcast_arrays</tt><big>(</big><em>*arrays</em><big>)</big><a class="headerlink" href="#dimarray.broadcast_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to numpy.broadcast_arrays</p>
<p>but with looser requirements on input shape
and returns copy instead of views</p>
<p>arrays: variable list of DimArrays</p>
</dd></dl>

<dl class="class">
<dt id="dimarray.DimArray">
<em class="property">class </em><tt class="descclassname">dimarray.</tt><tt class="descname">DimArray</tt><big>(</big><em>values=None</em>, <em>axes=None</em>, <em>dims=None</em>, <em>labels=None</em>, <em>copy=False</em>, <em>dtype=None</em>, <em>_indexing=None</em>, <em>_indexing_broadcast=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray" title="Permalink to this definition">¶</a></dt>
<dd><p>numpy&#8217;s ndarray with labelled dimensions and axes</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">T</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">box</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">box_ix</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">dims</span></tt></td>
<td>axis names</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dtype</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">ix</span></tt></td>
<td>integer index-access (toogle between integer-based and values-based indexing)</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">labels</span></tt></td>
<td>axis values</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">ndim</span></tt></td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">shape</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">size</span></tt></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.DimArray.broadcast" title="dimarray.DimArray.broadcast"><tt class="xref py py-obj docutils literal"><span class="pre">broadcast</span></tt></a>(other)</td>
<td>broadcast the array along a set of axes by repeating it as necessay</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dimarray.DimArray.reindex_like" title="dimarray.DimArray.reindex_like"><tt class="xref py py-obj docutils literal"><span class="pre">reindex_like</span></tt></a>(other[,&nbsp;method])</td>
<td>reindex like another axis</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.DimArray.reindex_axis" title="dimarray.DimArray.reindex_axis"><tt class="xref py py-obj docutils literal"><span class="pre">reindex_axis</span></tt></a>(values[,&nbsp;axis,&nbsp;method,&nbsp;repna,&nbsp;...])</td>
<td>reindex an array along an axis</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dimarray.DimArray.reset_axis" title="dimarray.DimArray.reset_axis"><tt class="xref py py-obj docutils literal"><span class="pre">reset_axis</span></tt></a>([values,&nbsp;axis,&nbsp;inplace])</td>
<td>Reset axis values and attributes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.DimArray.reshape" title="dimarray.DimArray.reshape"><tt class="xref py py-obj docutils literal"><span class="pre">reshape</span></tt></a>(*newdims,&nbsp;**kwargs)</td>
<td>Add/remove/group dimensions to conform array to new dimensions</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dimarray.DimArray.swapaxes" title="dimarray.DimArray.swapaxes"><tt class="xref py py-obj docutils literal"><span class="pre">swapaxes</span></tt></a>(a,&nbsp;axis1,&nbsp;axis2)</td>
<td>analogous to numpy&#8217;s swapaxes, but can provide axes by name</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.DimArray.to_pandas" title="dimarray.DimArray.to_pandas"><tt class="xref py py-obj docutils literal"><span class="pre">to_pandas</span></tt></a>()</td>
<td>return the equivalent pandas object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dimarray.DimArray.from_pandas" title="dimarray.DimArray.from_pandas"><tt class="xref py py-obj docutils literal"><span class="pre">from_pandas</span></tt></a>(data[,&nbsp;dims])</td>
<td>Initialize a DimArray from pandas</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.DimArray.to_dataset" title="dimarray.DimArray.to_dataset"><tt class="xref py py-obj docutils literal"><span class="pre">to_dataset</span></tt></a>([axis])</td>
<td>split a DimArray into a Dataset object (collection of DimArrays)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#dimarray.DimArray.write_nc" title="dimarray.DimArray.write_nc"><tt class="xref py py-obj docutils literal"><span class="pre">write_nc</span></tt></a>(f[,&nbsp;name])</td>
<td>Write DimArray instance to file</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="57%" />
<col width="43%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>mean, median, max, sum, diff, ...: most common along-axis numpy methods</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>group, ungroup</td>
<td>(flatten/inflate along particular sets of dimensions)</td>
</tr>
<tr class="row-odd"><td>transpose, squeeze</td>
<td>(similar to ndarray&#8217;s methods)</td>
</tr>
<tr class="row-even"><td>plot, pcolor, contourf, contour</td>
<td>(plotting methods)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dimarray.DimArray.broadcast">
<tt class="descname">broadcast</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>broadcast the array along a set of axes by repeating it as necessay</p>
<p>other             : DimArray or Axes objects or ordered Dictionary of axis values</p>
<p>Create some dummy data:
# ...create some dummy data:
&gt;&gt;&gt; import dimarray as da
&gt;&gt;&gt; lon = np.linspace(10, 30, 2)
&gt;&gt;&gt; lat = np.linspace(10, 50, 3)
&gt;&gt;&gt; time = np.arange(1950,1955)
&gt;&gt;&gt; ts = da.DimArray.from_kw(np.arange(5), time=time)
&gt;&gt;&gt; cube = da.DimArray.from_kw(np.zeros((3,2,5)), lon=lon, lat=lat, time=time)  # lat x lon x time
&gt;&gt;&gt; cube.axes  
dimensions: &#8216;lat&#8217;, &#8216;lon&#8217;, &#8216;time&#8217;
0 / lat (3): 10.0 to 50.0
1 / lon (2): 10.0 to 30.0
2 / time (5): 1950 to 1954</p>
<p># ...broadcast timeseries to 3D data
&gt;&gt;&gt; ts3D = ts.broadcast(cube) #  lat x lon x time
&gt;&gt;&gt; ts3D
dimarray: 30 non-null elements (0 null)
dimensions: &#8216;lat&#8217;, &#8216;lon&#8217;, &#8216;time&#8217;
0 / lat (3): 10.0 to 50.0
1 / lon (2): 10.0 to 30.0
2 / time (5): 1950 to 1954
array([[[0, 1, 2, 3, 4],</p>
<blockquote>
<div>[0, 1, 2, 3, 4]],</div></blockquote>
<dl class="docutils">
<dt>&lt;BLANKLINE&gt;</dt>
<dd><dl class="first last docutils">
<dt>[[0, 1, 2, 3, 4],</dt>
<dd>[0, 1, 2, 3, 4]],</dd>
</dl>
</dd>
<dt>&lt;BLANKLINE&gt;</dt>
<dd><dl class="first last docutils">
<dt>[[0, 1, 2, 3, 4],</dt>
<dd>[0, 1, 2, 3, 4]]])</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.contour">
<tt class="descname">contour</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2-D contours. Wraps matplotlib contour().
See contour documentation in matplotlib for accepted keyword arguments.</p>
<p>x = DimArray(np.zeros([100,40]))
x[:50,:20] = 1.
x.contour()
x.T.contour() # to flip horizontal/vertical axes</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.contourf">
<tt class="descname">contourf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.contourf" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot filled 2-D contours. Wraps matplotlib contourf().
See contourf documentation in matplotlib for accepted keyword arguments.</p>
<p>x = DimArray(np.zeros([100,40]))
x[:50,:20] = 1.
x.contourf()
x.T.contourf() # to flip horizontal/vertical axes</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.diff">
<tt class="descname">diff</tt><big>(</big><em>obj</em>, <em>axis=-1</em>, <em>scheme='backward'</em>, <em>keepaxis=False</em>, <em>n=1</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to numpy&#8217;s diff</p>
<blockquote>
<div><p>Calculate the n-th order discrete difference along given axis.</p>
<p>The first order difference is given by <tt class="docutils literal"><span class="pre">out[n]</span> <span class="pre">=</span> <span class="pre">a[n+1]</span> <span class="pre">-</span> <span class="pre">a[n]</span></tt> along
the given axis, higher order differences are calculated by using <cite>diff</cite>
recursively.</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis: axis along which to apply the tranform.</strong></p>
<blockquote>
<div><blockquote>
<div><p>Can be given as axis position (<cite>int</cite>), as axis name (<cite>str</cite>), as a 
<cite>list</cite> or <cite>tuple</cite> of axes (positions or names) to collapse into one axis before 
applying transform. If <cite>axis</cite> is <cite>None</cite>, just apply the transform on
the flattened array consistently with numpy (in this case will return
a scalar).
Default is <cite>-1</cite>.</p>
</div></blockquote>
<dl class="docutils">
<dt>scheme: str, determines the values of the resulting axis</dt>
<dd><p class="first last">&#8220;forward&#8221; : diff[i] = x[i+1] - x[i]
&#8220;backward&#8221;: diff[i] = x[i] - x[i-1]
&#8220;centered&#8221;: diff[i] = x[i+1/2] - x[i-1/2]
default is &#8220;backward&#8221;</p>
</dd>
<dt>keepaxis: bool, if True, keep the initial axis by padding with NaNs</dt>
<dd><p class="first last">Only compatible with &#8220;forward&#8221; or &#8220;backward&#8221; differences</p>
</dd>
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of times values are differenced.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>diff</strong> : DimArray</p>
<blockquote class="last">
<div><p>The <cite>n</cite> order differences. The shape of the output is the same as <cite>a</cite>
except along <cite>axis</cite> where the dimension is smaller by <cite>n</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="dimarray.DimArray.from_pandas">
<em class="property">classmethod </em><tt class="descname">from_pandas</tt><big>(</big><em>data</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a DimArray from pandas
data: pandas object (Series, DataFrame, Panel, Panel4D)
dims, optional: dimension (axis) names, otherwise look at ax.name for ax in data.axes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;c&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#39;dim0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DimArray</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">dimarray: 3 non-null elements (0 null)</span>
<span class="go">dimensions: &#39;dim0&#39;</span>
<span class="go">0 / dim0 (3): a to c</span>
<span class="go">array([3, 5, 6])</span>
</pre></div>
</div>
<p>Also work with Multi-Index
&gt;&gt;&gt; panel = pd.Panel(np.arange(2*3*4).reshape(2,3,4))
&gt;&gt;&gt; b = panel.to_frame() # pandas&#8217; method to convert Panel to DataFrame via MultiIndex
&gt;&gt;&gt; DimArray.from_pandas(b)    # doctest: +SKIP
dimarray: 24 non-null elements (0 null)
dimensions: &#8216;major,minor&#8217;, &#8216;x1&#8217;
0 / major,minor (12): (0, 0) to (2, 3)
1 / x1 (2): 0 to 1
...</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.group">
<tt class="descname">group</tt><big>(</big><em>*dims</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.group" title="Permalink to this definition">¶</a></dt>
<dd><p>group (or flatten) a subset of dimensions</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><ul class="first last">
<li><p class="first">dims: list or tuple of axis names</p>
</li>
<li><dl class="first docutils">
<dt>reverse [False]: if True, reverse behaviour: dims are interpreted as </dt>
<dd><p class="first last">the dimensions to keep, and all the other dimensions are grouped</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>insert, optional: position where to insert the grouped axis </dt>
<dd><blockquote class="first">
<div><p>(by default, any grouped dimension is inserted at</p>
</div></blockquote>
<p class="last">the position of the first axis involved in grouping)</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li>DimArray appropriately reshaped, with collapsed dimensions as first axis (tuples)</li>
</ul>
</dd>
</dl>
<p>This is useful to do a regional mean with missing values</p>
<p>Note: can be passed via the &#8220;axis&#8221; parameter of the transformation, too</p>
</dd></dl>

<dl class="attribute">
<dt id="dimarray.DimArray.max">
<tt class="descname">max</tt><em class="property"> = &lt;functools.partial object at 0x2b65a8d2aba8&gt;</em><a class="headerlink" href="#dimarray.DimArray.max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.mean">
<tt class="descname">mean</tt><big>(</big><em>obj</em>, <em>axis=None</em>, <em>skipna=False</em>, <em>weights='axis'</em>, <em>dtype=None</em>, <em>out=None</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>mean over an axis or group of axes, possibly weighted</p>
<blockquote>
<div><ul>
<li><p class="first">axis    : int, str, tuple: axis or group of axes to apply the transform on</p>
</li>
<li><p class="first">skipna  : remove nans prior to transformation?</p>
</li>
<li><dl class="first docutils">
<dt>weights <span class="classifier-delimiter">:</span> <span class="classifier">if weights, perform a weighted mean (see get_weights method)</span></dt>
<dd><p class="first last">the default behaviour (&#8220;axis&#8221;) is too look in individual axes 
whether they have a not-None weight attribute</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="dimarray.DimArray.median">
<tt class="descname">median</tt><em class="property"> = &lt;functools.partial object at 0x2b65a8d2af18&gt;</em><a class="headerlink" href="#dimarray.DimArray.median" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.pcolor">
<tt class="descname">pcolor</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.pcolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a quadrilateral mesh. Wraps matplotlib pcolormesh().
See pcolormesh documentation in matplotlib for accepted keyword arguments.</p>
<p>x = DimArray(np.zeros([100,40]))
x.pcolor()
x.T.pcolor() # to flip horizontal/vertical axes</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.plot">
<tt class="descname">plot</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>by default, use pandas for plotting (for now at least)</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.reindex_axis">
<tt class="descname">reindex_axis</tt><big>(</big><em>values</em>, <em>axis=0</em>, <em>method='exact'</em>, <em>repna=True</em>, <em>fill_value=nan</em>, <em>tol=None</em>, <em>use_pandas=None</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.reindex_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>reindex an array along an axis</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><ul class="first last">
<li><p class="first">values : array-like or Axis: new axis values</p>
</li>
<li><p class="first">axis   : axis number or name</p>
</li>
<li><p class="first">method : &#8220;exact&#8221; (default), &#8220;nearest&#8221;, &#8220;interp&#8221;</p>
</li>
<li><dl class="first docutils">
<dt>repna: if False, raise error when an axis value is not present </dt>
<dd><p class="first last">otherwise just replace with NaN. Defaulf is True</p>
</dd>
</dl>
</li>
<li><p class="first">fill_value: value to use instead of missing data</p>
</li>
<li><p class="first">tol: re-index with a particular tolerance (can be longer)</p>
</li>
<li><dl class="first docutils">
<dt>use_pandas, optional: bool <span class="classifier-delimiter">:</span> <span class="classifier">if True (the default), convert to pandas for re-indexing </span></dt>
<dd><p class="first last">If any special option (method, tol) is set or if modulo axes are present 
or, of course, if pandas is not installed,
this option is set to False by default.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li>DimArray</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reindex_axis</tt><big>(</big><em>values</em>, <em>axis=0</em>, <em>method='exact'</em>, <em>repna=True</em>, <em>fill_value=nan</em>, <em>tol=None</em>, <em>use_pandas=None</em><big>)</big></dt>
<dd><p>reindex an array along an axis</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><ul class="first last">
<li><p class="first">values : array-like or Axis: new axis values</p>
</li>
<li><p class="first">axis   : axis number or name</p>
</li>
<li><p class="first">method : &#8220;exact&#8221; (default), &#8220;nearest&#8221;, &#8220;interp&#8221;</p>
</li>
<li><dl class="first docutils">
<dt>repna: if False, raise error when an axis value is not present </dt>
<dd><p class="first last">otherwise just replace with NaN. Defaulf is True</p>
</dd>
</dl>
</li>
<li><p class="first">fill_value: value to use instead of missing data</p>
</li>
<li><p class="first">tol: re-index with a particular tolerance (can be longer)</p>
</li>
<li><dl class="first docutils">
<dt>use_pandas, optional: bool <span class="classifier-delimiter">:</span> <span class="classifier">if True (the default), convert to pandas for re-indexing </span></dt>
<dd><p class="first last">If any special option (method, tol) is set or if modulo axes are present 
or, of course, if pandas is not installed,
this option is set to False by default.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Output:</dt>
<dd><ul class="first last simple">
<li>DimArray</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.reindex_like">
<tt class="descname">reindex_like</tt><big>(</big><em>other</em>, <em>method='exact'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.reindex_like" title="Permalink to this definition">¶</a></dt>
<dd><p>reindex like another axis</p>
<p>note: only reindex axes which are present in other</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.reset_axis">
<tt class="descname">reset_axis</tt><big>(</big><em>values=None</em>, <em>axis=0</em>, <em>inplace=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.reset_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset axis values and attributes</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">reset_axis</tt><big>(</big><em>values=None</em>, <em>axis=0</em>, <em>inplace=False</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Reset axis values and attributes</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.reshape">
<tt class="descname">reshape</tt><big>(</big><em>*newdims</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Add/remove/group dimensions to conform array to new dimensions</p>
<dl class="docutils">
<dt>input:</dt>
<dd><p class="first">newdims: tuple or list or variable list of dimension names {str}</p>
<blockquote>
<div><p>Any dimension now present in the array is added as singleton dimension</p>
<p>Any dimension name containing a comma is interpreting as a grouping command.
All dimensions to group have to exist already.</p>
</div></blockquote>
<p class="last">transpose: {bool} if True, transpose dimensions to match new order (default True)</p>
</dd>
<dt>output:</dt>
<dd>reshape: DimArray with reshape.dims == tuple(newdims)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.squeeze">
<tt class="descname">squeeze</tt><big>(</big><em>axis=None</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Analogous to numpy, but also allows axis name</p>
</dd></dl>

<dl class="attribute">
<dt id="dimarray.DimArray.sum">
<tt class="descname">sum</tt><em class="property"> = &lt;functools.partial object at 0x2b65a8d2a9f0&gt;</em><a class="headerlink" href="#dimarray.DimArray.sum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.swapaxes">
<tt class="descname">swapaxes</tt><big>(</big><em>a</em>, <em>axis1</em>, <em>axis2</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>analogous to numpy&#8217;s swapaxes, but can provide axes by name</p>
<p>a        : DimArray (if used as function), or self (to be ignored) if used as method
axis1, axis2: <cite>int</cite> or <cite>str</cite>, axes to swap (transpose)</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.to_dataset">
<tt class="descname">to_dataset</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.to_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>split a DimArray into a Dataset object (collection of DimArrays)</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.to_pandas">
<tt class="descname">to_pandas</tt><big>(</big><big>)</big><a class="headerlink" href="#dimarray.DimArray.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>return the equivalent pandas object</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.transpose">
<tt class="descname">transpose</tt><big>(</big><em>*dims</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute dimensions</p>
<p>Analogous to numpy, but also allows axis names</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.ungroup">
<tt class="descname">ungroup</tt><big>(</big><em>axis=None</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.ungroup" title="Permalink to this definition">¶</a></dt>
<dd><p>opposite from group</p>
<p>axis: axis to ungroup as int or str (default: ungroup all)</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.DimArray.write_nc">
<tt class="descname">write_nc</tt><big>(</big><em>f</em>, <em>name=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.DimArray.write_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write DimArray instance to file</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descname">write_nc</tt><big>(</big><em>f</em>, <em>name=None</em>, <em>*args</em>, <em>**kwargs</em><big>)</big></dt>
<dd><p>Write DimArray instance to file</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dimarray.Dataset">
<em class="property">class </em><tt class="descclassname">dimarray.</tt><tt class="descname">Dataset</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.Dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for a set of aligned objects</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dims</span></tt></td>
<td>list of dimensions contained in the Dataset, consistently with DimArray&#8217;s <cite>dims</cite></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">clear</span></tt>(()&nbsp;-&gt;&nbsp;None.&nbsp;&nbsp;Remove&nbsp;all&nbsp;items&nbsp;from&nbsp;od.)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>(()&nbsp;-&gt;&nbsp;a&nbsp;shallow&nbsp;copy&nbsp;of&nbsp;od)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">fromkeys</span></tt>((S[,&nbsp;...)</td>
<td>If not specified, the value defaults to None.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt>((k[,d])&nbsp;-&gt;&nbsp;D[k]&nbsp;if&nbsp;k&nbsp;in&nbsp;D,&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">has_key</span></tt>((k)&nbsp;-&gt;&nbsp;True&nbsp;if&nbsp;D&nbsp;has&nbsp;a&nbsp;key&nbsp;k,&nbsp;else&nbsp;False)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">items</span></tt>(()&nbsp;-&gt;&nbsp;list&nbsp;of&nbsp;(key,&nbsp;value)&nbsp;pairs&nbsp;in&nbsp;od)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">iteritems</span></tt>()</td>
<td>od.iteritems -&gt; an iterator over the (key, value) pairs in od</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">iterkeys</span></tt>(()&nbsp;-&gt;&nbsp;an&nbsp;iterator&nbsp;over&nbsp;the&nbsp;keys&nbsp;in&nbsp;od)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">itervalues</span></tt>()</td>
<td>od.itervalues -&gt; an iterator over the values in od</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">keys</span></tt>(()&nbsp;-&gt;&nbsp;list&nbsp;of&nbsp;keys&nbsp;in&nbsp;od)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt>([axis])</td>
<td>Apply transformantion on every variable of the Dataset</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">median</span></tt>([axis])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">pop</span></tt>((k[,d])&nbsp;-&gt;&nbsp;v,&nbsp;...)</td>
<td>value.  If key is not found, d is returned if given, otherwise KeyError</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">popitem</span></tt>(()&nbsp;-&gt;&nbsp;(k,&nbsp;v),&nbsp;...)</td>
<td>Pairs are returned in LIFO order if last is true or FIFO order if false.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">read</span></tt>(f,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Read several (or all) variable from a netCDF file</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">read_nc</span></tt>(f,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Read several (or all) variable from a netCDF file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.Dataset.reset_axis" title="dimarray.Dataset.reset_axis"><tt class="xref py py-obj docutils literal"><span class="pre">reset_axis</span></tt></a>([values,&nbsp;axis,&nbsp;inplace])</td>
<td>Reset axis values and attributes in all dimarrays present in the dataset</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">setdefault</span></tt>((k[,d])&nbsp;-&gt;&nbsp;od.get(k,d),&nbsp;...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">std</span></tt>([axis])</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">take</span></tt>(indices[,&nbsp;axis,&nbsp;raise_error])</td>
<td>analogous to DimArray&#8217;s take, but for each DimArray of the Dataset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.Dataset.to_array" title="dimarray.Dataset.to_array"><tt class="xref py py-obj docutils literal"><span class="pre">to_array</span></tt></a>([axis,&nbsp;keys,&nbsp;_constructor])</td>
<td>Convert to DimArray</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_dict</span></tt>()</td>
<td>export to dict</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_odict</span></tt>()</td>
<td>export to ordered dict</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">update</span></tt>(([E,&nbsp;...)</td>
<td>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">values</span></tt>(()&nbsp;-&gt;&nbsp;list&nbsp;of&nbsp;values&nbsp;in&nbsp;od)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">var</span></tt>([axis])</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">viewitems</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">viewkeys</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">viewvalues</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">write</span></tt>(f,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write Dataset to netCDF file</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#dimarray.Dataset.write_nc" title="dimarray.Dataset.write_nc"><tt class="xref py py-obj docutils literal"><span class="pre">write_nc</span></tt></a>(f,&nbsp;*args,&nbsp;**kwargs)</td>
<td>Write Dataset to netCDF file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="dimarray.Dataset.reset_axis">
<tt class="descname">reset_axis</tt><big>(</big><em>values=None</em>, <em>axis=0</em>, <em>inplace=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.Dataset.reset_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset axis values and attributes in all dimarrays present in the dataset</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.Dataset.to_array">
<tt class="descname">to_array</tt><big>(</big><em>axis=None</em>, <em>keys=None</em>, <em>_constructor=None</em><big>)</big><a class="headerlink" href="#dimarray.Dataset.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to DimArray</p>
<p>axis  : axis name, by default &#8220;unnamed&#8221;</p>
</dd></dl>

<dl class="method">
<dt id="dimarray.Dataset.write_nc">
<tt class="descname">write_nc</tt><big>(</big><em>f</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.Dataset.write_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write Dataset to netCDF file</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="dimarray.Axis">
<em class="property">class </em><tt class="descclassname">dimarray.</tt><tt class="descname">Axis</tt><big>(</big><em>values</em>, <em>name=''</em>, <em>weights=None</em>, <em>modulo=None</em>, <em>dtype=None</em>, <em>_monotonic=None</em>, <em>tol=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.Axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Axis</p>
<p>values: numpy array (or list) 
name  : name (attribute)</p>
<p>weights: [None] associated list of weights 
modulo: [None] if not None, consider axis values as being defined +/- n*modulo, where n is an integer</p>
<blockquote>
<div>this modify <cite>loc</cite> behaviour only, but does not impose any constraint on actual axis values</div></blockquote>
<p>tol: [None], if not None, attempt a nearest neighbour search with specified tolerance</p>
<ul class="simple">
<li>metadata</li>
</ul>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">dtype</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">loc</span></tt></td>
<td>Access the slicer to locate axis elements</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">size</span></tt></td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">weights</span></tt></td>
<td></td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="63%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>modulo</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>tol</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">from_pandas</span></tt>(index)</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_weights</span></tt>([weights])</td>
<td>return axis weights as a DimArray</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_monotonic</span></tt>()</td>
<td>return True if monotonic</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_numeric</span></tt>()</td>
<td>numeric type?</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_regular</span></tt>()</td>
<td>return True if regular axis (numeric and steadily increasing)</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reset</span></tt>([values,&nbsp;inplace])</td>
<td>Reset axis values and attributes</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">to_pandas</span></tt>()</td>
<td>convert to pandas Index</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">union</span></tt>(other)</td>
<td>join two Axis objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="dimarray.Axes">
<em class="property">class </em><tt class="descclassname">dimarray.</tt><tt class="descname">Axes</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#dimarray.Axes" title="Permalink to this definition">¶</a></dt>
<dd><p>Axes class: inheritates from a list but dict-like access methods for convenience</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">loc</span></tt></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt>(item)</td>
<td>add a check on axis</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt>()</td>
<td></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt>(...)</td>
<td></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">extend</span></tt></td>
<td>L.extend(iterable) &#8211; extend list by appending elements from the iterable</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">from_arrays</span></tt>(arrays[,&nbsp;dims])</td>
<td>list of np.ndarrays and dims</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">from_dict</span></tt>(kwaxes[,&nbsp;dims,&nbsp;shape,&nbsp;raise_warning])</td>
<td>infer dimensions from key-word arguments</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">from_shape</span></tt>(shape[,&nbsp;dims])</td>
<td>return default axes based on shape</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">from_tuples</span></tt>(*tuples_name_values)</td>
<td>initialize axes from tuples</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_idx</span></tt>(axis)</td>
<td>always return axis integer location</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">index</span></tt>((value,&nbsp;[start,&nbsp;...)</td>
<td>Raises ValueError if the value is not present.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">insert</span></tt></td>
<td>L.insert(index, object) &#8211; insert object before index</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">pop</span></tt>(...)</td>
<td>Raises IndexError if list is empty or index is out of range.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">remove</span></tt></td>
<td>L.remove(value) &#8211; remove first occurrence of value.</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">reset_axis</span></tt>([values,&nbsp;axis,&nbsp;inplace])</td>
<td>Reset axis values and attributes</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">reverse</span></tt></td>
<td>L.reverse() &#8211; reverse <em>IN PLACE</em></td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt>(dims)</td>
<td>sort IN PLACE according to the order in &#8220;dims&#8221;</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/modules.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">dimarray 0.1.7.dev documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mahe Perrette.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>