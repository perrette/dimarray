==========================================
dimarray: Array with meaningful dimensions
==========================================

Highlights
----------

* numpy's ndarrays with labelled axes, metadata and NaN handling
* inspired by pandas but generalized to any dimension
* forget the underlying array shape and concentrate on what you aim to do
* intuitive multi-dimensional "slicing"/reshaping/reindexing by dimension name
* mean, sum, cumsum and so on applicable on any subset of dimensions (by name)
* handles axis-based weights (e.g. for averaging)
* arithmetics between arrays of different dimensions with axis alignment
* natural netCDF I/O (requires HDF5, netCDF4)


Main classes and functions
--------------------------

* Dimarray		    : main data structure (see alias `array`)
* Dataset		    : ordered dictionary of Dimarray objects
* Axes, Axis		    : axis and indexing
* read, write, summary	    : netCDF I/O

Get started
-----------

>>> import numpy as np
>>> from dimarray import Dimarray
>>> import dimarray as da

Define some dummy data representing 3 items "a", "b" and "c" over 5 years:

>>> values = np.random.randn(3,5)

Defining a Dimarray from there is pretty straightforward

>>> a = Dimarray(values)   # fully automatic labelling
>>> a = Dimarray(values, 'items', 'time')  # axis values assumed [0, 1, 2,...]
>>> a = Dimarray(values, list("abc"), np.arange(1950,1955)) # "x0","x1" 
>>> a = Dimarray(values, ('items',list("abc")), ('time',np.arange(1950,1955)))  # all labels
>>> a
dimarray: 15 non-null elements (0 null)
dimensions: 'items', 'time'
0 / items (3): a to c
1 / time (5): 1950 to 1954
array([[ 1.1428796 ,  0.41841267,  0.85425341,  0.27862345,  2.26674182],
       [-1.34229184,  0.03654742, -0.6399767 ,  0.27653369,  0.62407923],
       [ 0.94191144,  1.21903161,  0.95405128,  1.81493798, -0.58801474]])

For convenience, it is also possible to define an array via keyword arguments
(but note this is unambiguous only when axes have different size, see tutorial)

>>> b = Dimarray.from_kwds(values, items=list("abc"), time=np.arange(1950,1955))
>>> a == b     
True

Can access underlying numpy array via `values` attributes

>>> a.values  # doctest: +ELLIPSIS
array(...)

And the axes, too:

>>> a.time
>>> a.items
>>> np.all( a.time == a.axes["time"].values )
True

Easy slicing (xs for cross-section):

>>> a.xs(time=1952)
>>> a.xs(time=1952, items="b")
>>> a.xs(time=(1952,1954))
>>> a[:, 1952:1954] == a.xs(time=(1952,1954))
True
>>> a.iloc[:, 2:5] # integer access

Arithmetics with reshaping and axis alignment

>>> ts = da.array(np.random.randn(10), time=np.arange(1950, 1955)) # alias for Dimarray.from_kwds
>>> a * ts   # not commutative !  # doctest: +ELLIPSIS
dimarray: 15 non-null elements (0 null)
dimensions: 'items', 'time'
0 / items (3): a to c
1 / time (5): 1950 to 1954
array(...)
>>> mymap = da.array(np.random.randn(5,10), lon=np.linspace(0,360,10), lat=np.linspace(-90.90,5))
>>> mycube = mymap * ts   # doctest: +ELLIPSIS
>>> mycube
...
dimensions: 'lat', 'lon', 'time'
0 / lat (5): 0. to 360.
1 / lon (10): -90. to 90.
2 / time (5): 1950 to 1954
array(...)

All numpy transforms work (with NaN checking)

>>> mycube.mean(axis="time") 

>>> a.values.mean(axis=1) == a.mean(axis="time").values  
True

Can also provide a subset of several dimensions as argument to operate on flattened array.

>>> mycube.mean(axis=("lat","lon"))

NetCDF I/O

>>> a.write("test.nc","myvar") # write to netCDF4
>>> da.summary("test.nc") # check the content
>>> dataset = da.read("test.nc") # read in a Dataset class
>>> dataset["myvar"] == a
True

Easy interfacing with pandas

>>> a.to_pandas()
>>> a.to_pandas().plot()

More complete documentation will follow...
